线程安全的核心在于要对状态访问操作进行管理，特别是对共享(Shared)的和可变的(Mutable)状态的访问.

在安全和性能条件下，首先要是代码正确运行，然后在提高程序运行速度



线程安全的类组成的类不一定是线程安全的



原子性：

```java
int i = 0;

int getValue() {
    i++;
    return i;
}
```

上面的 i++ 不是变成安全的，包含 读取-修改-写入 三个步骤，多个线程同时访问，可能出在 i 变化的不同阶段，所以这个方法不是线程安全的，i 不具备原子性



竟态条件：

当某个计算的正确性取决于多个线程的交替执行时序，就会发生静态条件，也就是说正确的结果取决于运气。下面是两种情形

1. 先检查后执行：单例

   ```java
   public class Demo {
       private static Demo demo;
       
       public static Demo getInstance() {
           if(demo == null) {
               demo = new Demo();
           }
           return demo;
       }
   }
   ```

2. 读取-修改-写入：参考 i++

   消除方式：使用 AtommicInt 类型



内置锁：每个java对象都可以用作一个实现同步的锁



重入：

内置锁是可以重入的，获取锁操作的粒度是线程，而不是操作

每个锁关联一个计数值和一个线程，线程第一次获得这个锁并进行调用，这个值是 1，方法里面再获取这个锁，计数值是2，依次递增，当执行完，计数值减1，当计数值为0的时候，释放这个锁。





